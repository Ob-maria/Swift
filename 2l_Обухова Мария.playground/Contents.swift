import UIKit

//1. Написать функцию, которая определяет, четное число или нет.

var a = 25

func fu () {
    if a % 2 == 0 {
        print ("Число четное")
    } else {
        print ("Число не четное")
    }
}
fu()

//2. Написать функцию, которая определяет, делится ли число без остатка на 3.

var b = 33

func fun () {
    if b % 3 == 0 {
        print ("Число делится на 3 без остатка")
    } else {
        print ("Число не делится на 3 без остатка")
    }
}
fun()

//3. Создать возрастающий массив из 100 чисел.
var c : [Int] = []
for i in 1...100 {
    c.append(i)
}
print (c)

//4. Удалить из этого массива все четные числа и все числа, которые не делятся на 3 без остатка.
var f1 : [Int] = []
for i in 1...100 {
    f1.append(i)
}

for i in f1 {
    if (i % 3 != 0) || (i % 2 == 0) {
            if let index = f1.firstIndex (of: i) {
            f1.remove(at: index)
        }
    }
}

print (f1)

//5. * Написать функцию, которая добавляет в массив новое число Фибоначчи, и добавить при помощи нее 50 элементов.

func fibonachi(_ count: Int) -> [Double] {
    var newArray: [Double] = []
    if count == 1 {//проверяем переданный в функцию аргумент, так как первый и единственный аргумент числа Фибоначчи 0
        let f0: Double = 0 //создаем переменную равную 0
        newArray.append(f0) //добавляем элемент в массив
    } else if count == 2 {//если передаваемый аргумент равен 2, значит в массив нужно добавить 2 первых числа это 0 и 1
        let f1: Double = 1 //создаем два эти элемента
        let f0: Double = 0 //создаем два эти элемента
        newArray.append(f0) //добавляем элементы в массив
        newArray.append(f1) //добавляем элементы в массив
    } else { //если передаваемый элемент более 2х значит нужно производить расчет значения чисел Фибоначчи
        let f1: Double = 1 // первые два элемента добавляются как и в предыдущим варианте
        let f0: Double = 0
        newArray.append(f0)
        newArray.append(f1)
        var n = 2 // так как у нас уже есть первые два элемента 0 и 1 n = 2
        while n < count + 2 { //проверяем пока n меньше того аргумента который мы передали, значит будем выполнять следующие действия
            let n1 = (newArray[n-1]) + (newArray[n-2]) //[n-1] и [n-2] так мы рассчитываем индексы значений в массиве которые мы хотим сложить
            newArray.append(n1) //добавляем сумма значений из массива в наш массив
            n+=1 //увеличиваем значение n чтобы продолжать проходить по нашему циклу
        }
    }
    return newArray //выводим массив
}
print(fibonachi(2)) //производим вывод массива через вызыв функции и передаем аргумент равный необходимому количеству элементов числа Фибоначчи
print(fibonachi(100))

/* 6. * Заполнить массив из 100 элементов различными простыми числами. Натуральное число, большее единицы, называется простым, если оно делится только на себя и на единицу. Для нахождения всех простых чисел не больше заданного числа n, следуя методу Эратосфена, нужно выполнить следующие шаги:
a. Выписать подряд все целые числа от двух до n (2, 3, 4, ..., n).
b. Пусть переменная p изначально равна двум — первому простому числу.
c. Зачеркнуть в списке числа от 2 + p до n, считая шагом p..
d. Найти первое не зачёркнутое число в списке, большее, чем p, и присвоить значению переменной p это число.
e. Повторять шаги c и d, пока возможно.
 */

func isMultiple(_ num: Int, of divider: Int) -> Bool {
    return num % divider == 0 //функция для проверки на четность
}

var integers: [Int] = [] //пустой массив

while integers.count != 10 { //заполняем массив элементами
    integers.append(integers.count+2)
}
print(integers)
var p: Int
var index = 0
while index < integers.count - 1 {
    p = integers[index] //значение на которое будем делить все элементы массива
    
    for num in integers {
        if (num != p) && isMultiple(num, of: p){ //проверяем делится ли число на p без остатка, если делится то это не простое число
            integers.remove(at: integers.firstIndex(of: num)!) //удаляем элемент из массива
        }
    }
    index += 1
}

print(integers)
